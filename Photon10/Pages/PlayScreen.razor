
@*Todo: Add database input from entry screen, fix layout of screen,change eventbox to make it fixed size*@

<body class="bg-dark text-dark">
    <div id="gameTimerContainer" class="text-white">
        <button class="btn-danger" @onclick="OnStopGameClicked">Stop Game</button>
        @*TEMP*@
        <button class="btn-warning" @onclick="StateHasChanged">Force Refresh</button> 
        <CountdownTimer/>
        <WarningTimer />
    </div>
    <section id="player_list" class="bg-black" >
        <div class="container-fluid">
            <div class="row">
                <PlayerList Team1Players="Team1PlayerData" Team2Players="Team2PlayerData" @ref="GamePlayerList"/>
                
                
            </div>
        </div>
    </section>
    <section id="events" style="background-color: #484747;">
        <div class ="container-fluid">
            <div class="row">
                <div class="col-3"></div>
                <div class="col-6 my-4">
                    <h2 class= "events text-center">events</h2>
                    <div class="dashed_boarder events p-5">
                         @foreach(var e in GameEventLog)
                        {
                            <p>@e</p>
                        }
                    </div>
                </div>
                <div class="col-3"></div>
            </div>
        </div>
    </section>
</body>
@code {
    [Parameter]
    public List<Models.Player> Team1Players { get; set; } = new();
    [Parameter]
    public List<Models.Player> Team2Players { get; set; } = new();
    [Parameter]
    public List<string> GameEventLog { get; set; } = new();
    [Parameter]
    public List<PlayerGameData> Team1PlayerData { get; set; } = new();
    [Parameter]
    public List<PlayerGameData> Team2PlayerData { get; set; } = new();
    private PlayerList GamePlayerList { get; set; }
    private GameHandler gameHandler = new();
    private bool gameRunning = false;
    GameUpdated gameUpdateProcessed;
    public Task gameLoop;
    private bool gameEventsPending = false;
    private void OnStopGameClicked()
    {
        gameRunning = false;
        gameHandler.StopGame();
        StateHasChanged();
    }
    private void StartGame()
    {
        gameUpdateProcessed = new(OnGameUpdated);
        gameRunning = true;
        //gameHandler.UpdateProcessed += gameUpdateProcessed;
        gameHandler.StartListener();
    }
    private async Task UpdateGame()
    {
        await Task.Delay(500);
        await gameHandler.UpdateAsync();
        OnGameUpdated();
    }
    private void OnGameUpdated()
    {
        while(!gameHandler._eventsSinceLastUpdate.IsEmpty)
        {
            if(gameHandler._eventsSinceLastUpdate.TryDequeue(out var e))
            {
                GameEventLog.Add(e);
            }
        }
        for(int i = 0; i < Team1PlayerData.Count; i++)
        {
            var data = gameHandler.GetPlayerData(Team1PlayerData[i].Player.Id);
            Team1PlayerData[i] = data;
        }
        for(int i = 0; i < Team2PlayerData.Count; i++)
        {
            var data = gameHandler.GetPlayerData(Team2PlayerData[i].Player.Id);
            Team2PlayerData[i] = data;
        }
        StateHasChanged();
    }
    protected override void OnAfterRender(bool firstRender)
    {
        UpdateGame();
        base.OnAfterRender(firstRender);
    }
    protected override void OnInitialized()
    {
        gameRunning = true;
        foreach(var player in Team1PlayerData)
        {
            gameHandler.AddTrackedPlayer(player.Player, 1);
        }
        foreach(var player in Team2PlayerData)
        {
            gameHandler.AddTrackedPlayer(player.Player, 2);
        }
        StartGame(); //TEMP
        base.OnInitialized();
    }

}
